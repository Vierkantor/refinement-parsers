\documentclass{beamer}

\usepackage{fontspec}
\usepackage{minted}
\usepackage{xspace}

\setmainfont{TeX Gyre Heros}
\setmonofont{Noto Sans Mono}
\usetheme{Madrid}

\let \parskip=\baselineskip
\setminted{fontsize=\footnotesize}

\newcommand{\Agda}[1]{\texttt{\footnotesize #1}\xspace}
\newcommand{\Free}{\Agda{Free}}
\newcommand{\match}{\Agda{match}}
\newcommand{\Nondet}{\Agda{Nondet}}
\newcommand{\Regex}{\Agda{Regex}}
\newcommand{\Set}{\Agda{Set}}

\title[Combining predicate transformer semantics]{Combining predicate transformer semantics for effects: a case study in parsing regular languages}
\author{Anne Baanen \and Wouter Swierstra}
\date{September 1, 2020}

\begin{document}

\titlepage
\begin{frame}[fragile]{Algebraic effects}

Algebraic effects separate the syntax and semantics of effects.

\begin{itemize}
	\item The syntax describes the sequencing of the primitive operations
	\item The semantics assigns meaning to these operations
\end{itemize}

\begin{minted}{Agda}
data Free (C : Set) (R : C -> Set) : Set -> Set where
	Pure : a -> Free C R a
	Op : (c : C) -> (k : R c -> Free C R a) -> Free C R a
\end{minted}
\end{frame}

\begin{frame}[fragile]{Example: Nondeterminism}

\Agda{Nondet} has two primitive operations:
\begin{itemize}
    \item \Agda{Choice} chooses between two values
    \item \Agda{Fail} goes to a failure state and stops execution
\end{itemize}
\begin{minted}{Agda}
data CNondet where
	Choice : CNondet
	Fail : CNondet

RNondet : CNondet -> Set
RNondet Choice = Bool
RNondet Fail = ⊥

Nondet = Free CNondet RNondet
\end{minted}
\end{frame}

\begin{frame}[fragile]{Semantics for algebraic effects}
\emph{Handlers} give semantics for the \Free monad naturally as a fold:
\begin{minted}{Agda}
handleList : Nondet a -> List a
handleList (Pure x) = [x]
handleList (Op Choice k) = k True ++ k False
handleList (Op Fail k) = []
\end{minted}

\pause
The generic fold that computes a predicate of type \Set:
\begin{minted}{Agda}
[[_]] : Free C R a -> ((c : C) -> (R c -> Set))
      -> (a -> Set) -> Set
[[ Pure x ]] alg P = P x
[[ Op c k ]] alg P = alg c (λ x -> [[ k x ]] alg P)
\end{minted}
\end{frame}

\begin{frame}[fragile]{Predicate transformer semantics}

A predicate transformer for commands \Agda{C} and responses \Agda{R}
is a function from postconditions of type \Agda{R -> Set} to preconditions of type \Agda{C -> Set}.
If \Agda{R} depends on \Agda{C}, this becomes:

\begin{minted}{Agda}
pt C R = (c : C) -> (R c -> Set) -> Set
\end{minted}

The type of the algebra passed to \Agda{[[\_]]} is exactly \Agda{pt C R}.
We have assigned \emph{predicate transformer semantics} to algebraic effects.

\end{frame}

\begin{frame}[fragile]{Predicate transformer semantics for \Nondet}

For nondeterminism, there are two canonical choices of predicate transformer semantics.

\Agda{ptAll} requires that all potential results satisfy the postcondition:
\begin{minted}{Agda}
ptAll Fail k = ⊤
ptAll Choice k = k True ∧ k False
\end{minted}

\Agda{ptAny} requires that there is at least one outcome that satisfies the postcondition:
\begin{minted}{Agda}
ptAny Fail k = ⊥
ptAny Choice k = k True ∨ k False
\end{minted}

\end{frame}

\begin{frame}[fragile]{Parsing regular expressions}
To illustrate these semantics, we wrote a parser.
The input is a regular expression and a \Agda{String}, and the output a parse tree.
\begin{minted}{Agda}
data Regex : Set where
    Empty : Regex
    Epsilon : Regex
    Singleton : Char → Regex
    _ | _ : Regex → Regex → Regex
    _ · _ : Regex → Regex → Regex
    _ * : Regex → Regex

Tree : Regex -> Set
Tree Empty         = ⊥
Tree Epsilon       = ⊤
Tree (Singleton _) = Char
Tree (l | r)       = Either (Tree l) (Tree r)
Tree (l · r)       = Pair (Tree l) (Tree r)
Tree (r *)         = List (Tree r)
\end{minted}
\end{frame}

\begin{frame}[fragile]{Parsing regular expressions}
\begin{minted}{Agda}
match : (r : Regex) -> String -> Nondet (Tree r)
match Empty         xs       = Op Fail λ()
match Epsilon       Nil      = Pure tt
match Epsilon       (_ :: _) = Op Fail λ()
match (Singleton c) xs       =
    if xs = [c] then Pure c else Op Fail λ()

match (l | r)       xs       = Op Choice (λ b ->
    if b then Inl <$> match l xs else Inr <$> match r xs)

match (l · r) xs = do
    (ys, zs) <- allSplits xs
    (,) <$> match l ys <*> match r zs
\end{minted}
Looks straightforward so far...

\pause
... until we reach the last case:
\vspace{-\baselineskip}
\begin{minted}{Agda}
match (r *) xs = match (r · (r *)) xs
    -- Error: does not terminate
\end{minted}

\end{frame}

\begin{frame}[fragile]{Parsing regular expressions}
For now, we will write:
\vspace{-\baselineskip}
\begin{minted}{Agda}
match (r *) xs = Op Fail λ()
\end{minted}
\vspace{\baselineskip}

\pause

To verify our implementation, we take a specification consisting of precondition and postcondition:
\begin{minted}{Agda}
pre : Regex -> String -> Set
pre r xs = hasNo* r

post : (r : Regex) -> String -> Tree r -> Set
post r xs t = Match r xs t
\end{minted}

And check that \Agda{match} \emph{refines} this specification.

\end{frame}

\begin{frame}[fragile]{Refinement calculus}

A predicate transformer \Agda{pt1} \emph{is refined by} \Agda{pt2} if \Agda{pt2} satisfies more postconditions than \Agda{pt1}:
\vspace{-\baselineskip}
\begin{minted}{Agda}
_⊑_ : (pt1 pt2 : (a -> Set) -> Set) -> Set
pt1 ⊑ pt2 = ∀ P -> pt1 P -> pt2 P
\end{minted}

\Agda{S ⊑ T} expresses that \Agda{T} is ``better'' than \Agda{S}:
\Agda{S} can be replaced with \Agda{T} everywhere, and all postconditions will still hold.

\vspace{\baselineskip}

\pause

Predicate transformers are a semantic domain where programs and specifications can be related.
\vspace{-\baselineskip}
\begin{minted}{Agda}
[[_,_]] : (pre : Set) (post : a -> Set) -> (a -> Set) -> Set
[[ pre , post ]] P = pre ∧ ∀ x, post x -> P x
\end{minted}

\end{frame}

\begin{frame}[fragile]{Verification}

With these ingredients, the correctness statement of \match becomes:
\begin{minted}{Agda}
matchSound : (r : Regex) (xs : String) ->
    [[ pre r xs , post r xs ]] ⊑ [[ match r xs ]] ptAll
\end{minted}

The proof proceeds by case distinction and is uncomplicated, until we need to reason about the monadic bind operator \Agda{\_>>=\_}.

\pause

The missing ingredient is the rule of consequence:
\begin{minted}{Agda}
consequence : ∀ pt (S : Free es a) (f : a → Free es b) →
    [[ S ]] pt (λ x → [[ f x ]] pt P) ≡ [[ mx >>= f ]] pt P
\end{minted}

\end{frame}

\begin{frame}[fragile]{Adding effects}
The problem with \match is that implementing the Kleene star also requires the effect of \emph{general recursion}.

We can add more effects to the free monad by choosing the command and response types from a list of \emph{effect signatures}:
\begin{minted}{Agda}
data Free (es : List Sig) : Set -> Set where
    Pure : a -> Free es a
    Op : (i : mkSig C R ∈ es) (c : C)
         (k : R c -> Free C R a) -> Free C R a
\end{minted}

We will add two new effects: general recursion and parsing.
\end{frame}

\begin{frame}[fragile]{Adding effects}
The \Agda{Rec I O} effect represents a recursive function of type \Agda{(i : I) -> O i} calling itself.
The commands are the arguments to the function and the responses are the returned values.
\begin{minted}{Agda}
Rec : (I : Set) (O : I -> Set) -> Sig
Rec I O = mkSig I O
\end{minted}
To specify the semantics of \Agda{Rec}, we need an invariant of type \Agda{(i : I) -> O i -> Set},
specifying which values of type \Agda{O i} can be returned from a call with argument \Agda{i : I}.
\begin{minted}{Agda}
ptRec inv i P = ∀ o -> inv i o -> P o
\end{minted}
\end{frame}

\begin{frame}[fragile]{Adding effects}
The \Agda{Parser} effect represents a stateful parser with one command:
advance the input string by one character.

\begin{minted}{Agda}
Parser : Sig
Parser = mkSig ⊤ (λ _ -> Maybe Char)
\end{minted}

\Agda{Parser} has stateful semantics: to return the next character, we need to keep track of the remaining characters.
The state is the extra \Agda{String} arguments in \Agda{ptParser}.
\begin{minted}{Agda}
ptParser : ⊤ -> (Maybe Char -> String -> Set) -> String -> Set
ptParser _ P Nil = P Nothing Nil
ptParser _ P (x :: xs) = P (Just x) xs
\end{minted}

\end{frame}

\begin{frame}[fragile]{Extending \match}

Now we can finish the definition and prove soundness unconditionally:
\begin{minted}{Agda}
match (r *) = Op iRec (r · (r *))

matchSound : (r : Regex) (xs : String) ->
    [[ ⊤ , post r xs ]] ⊑ [[ match r xs ]]
\end{minted}

\pause
\match still does not terminate if \Agda{r} matches the empty string, our result is only \emph{partial correctness}.\\
\Agda{ptRec} computes the WLP: all recursive calls immediately return.
\end{frame}

\begin{frame}[fragile]{Defining a derivative-based matcher}
To guarantee termination, use recursion on \Agda{xs} rather than \Agda{r}.\\
The \emph{Brzozowski derivative} \Agda{d r /d x} matches \Agda{xs} iff \Agda{r} matches \Agda{x :: xs};\\ \Agda{integralTree r : tree (d r /d x) -> tree r} ``integrates'' parse trees.

\begin{minted}{Agda}
dmatch : (r : Regex) -> Free es (tree r)
dmatch r = symbol >>= maybe
    (λ x -> Op iRec (d r /d x) (integralTree r))
    (if p <- matchEpsilon r
     then Pure (Sigma.fst p)
     else Op iND Fail λ())
\end{minted}

\pause

\begin{minted}{Agda}
dmatchSound : ∀ r xs -> [[ match r xs ]] ⊑ [[ dmatch r xs ]]
\end{minted}
\end{frame}

\begin{frame}[fragile]{Termination checking}
\Agda{ptRec} gives weakest liberal precondition semantics.
For total correctness, we should check termination.

\vspace{\baselineskip}
\Agda{terminates-in f S n} holds iff \Agda{S} terminates after calling \Agda{f} at most \Agda{n} times.
\vspace{-\baselineskip}

\begin{minted}{Agda}
terminates-in : (f : (i : I) -> Free (Rec I O :: es) (O i))
    (S : Free (Rec I O :: es) a) → ℕ → Set
terminates-in f (Pure x)           n        = ⊤
terminates-in f (Op ∈Head c k)     Zero     = ⊥
terminates-in f (Op ∈Head c k)     (Succ n) =
    terminates-in pt f (f c >>= k) n
terminates-in f (Op (∈Tail i) c k) n        =
    pts i c (λ x → terminates-in f (k x) n)
\end{minted}
\end{frame}

\begin{frame}[fragile]{Total correctness}

Partial correctness of \Agda{dmatch} follows from the chain of refinements:
\begin{minted}{Agda}
[[ ⊤ , post r xs ]]
    ⊑ [[ match r xs ]]
    ⊑ [[ dmatch r xs ]]
    ⊑ [[ ⊤ , post r xs ]]
\end{minted}
together with a proof of termination:
\begin{minted}{Agda}
dmatchTerminates : (r : Regex) (xs : String) ->
    terminates-in dmatch (dmatch r xs) (length xs)
\end{minted}

\end{frame}

\begin{frame}{Discussion}

In our paper, we illustrate how techniques from the refinement calculus can be used in functional programming.
They provide a natural and uniform way to reason about effects in the setting of the \Agda{Free} monad.

A distinguishing characteristic of our approach is modularity:
we add new effects and semantics to the system as we need them.

Formally verified parsers have been developed before,
using specialized semantics to the domain of parsing.
The modularity of predicate transformers allow us to reason about effects uniformly.

Most existing approaches to recursion in parsers deal with termination syntactically.
Separation of syntax and semantics also cleanly separates partial and total correctness.

\end{frame}

\end{document}
